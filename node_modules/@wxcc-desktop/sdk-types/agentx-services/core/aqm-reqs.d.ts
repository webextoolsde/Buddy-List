import { Err, Signal } from "@uuip/unified-ui-platform-sdk";
import { AxiosError, AxiosResponse } from "axios";
import { AqmNotifs } from "./aqm-notifs";
export declare const TIMEOUT_REQ = 20000;
export declare class AqmReqs {
    private pendingRequests;
    private pendingEvents;
    constructor(notifs: AqmNotifs);
    req<TRes, TErr, TReq>(c: Conf<TRes, TErr, TReq>): Res<TRes, TReq>;
    reqEmpty<TRes, TErr, TReq>(c: ConfEmpty<TRes, TErr>): ResEmpty<TRes>;
    evt<T>(p: EvtConf<T>): EvtRes<T>;
    private createPromise;
    private bindPrint;
    private bindCheck;
    private readonly onMessage;
}
declare module "@uuip/unified-ui-platform-sdk" {
    namespace Err {
        interface Ids {
            "Service.aqm.reqs": ReqError;
        }
    }
}
export declare type Msg<T = any> = {
    type: string;
    orgId: string;
    trackingId: string;
    data: T;
};
declare type ReqError = "Service.aqm.reqs.GenericRequestError" | {
    "Service.aqm.reqs.Pending": {
        key: string;
        msg: string;
    };
} | {
    "Service.aqm.reqs.PendingEvent": {
        key: string;
    };
} | {
    "Service.aqm.reqs.Timeout": {
        key: string;
        resAxios: AxiosResponse;
    };
} | {
    "Service.aqm.reqs.TimeoutEvent": {
        key: string;
    };
};
declare type Req<TRes, TErr> = {
    url: string;
    host?: string;
    method?: "get" | "post" | "patch";
    err?: Err.IdsMessage | ((e: AxiosError) => Err.Message | Err.Details<Err.IdsDetails>);
    notifSuccess: {
        bind: Record<string, any>;
        msg: TRes;
    };
    notifFail?: {
        bind: Record<string, any>;
        errMsg: TErr;
        err: (e: TErr) => Err.Details<Err.IdsDetails>;
    } | {
        bind: Record<string, any>;
        errId: Err.IdsDetails;
    };
    data?: any;
    headers?: Record<string, string>;
    timeout?: Timeout;
};
declare type Timeout = number | "disabled";
declare type Conf<TRes, TErr, TReq> = (p: TReq) => Req<TRes, TErr>;
declare type ConfEmpty<TRes, TErr> = () => Req<TRes, TErr>;
declare type Res<TRes, TReq> = (p: TReq, cbRes?: CbRes<TRes>) => Promise<TRes>;
declare type ResEmpty<TRes> = (cbRes?: CbRes<TRes>) => Promise<TRes>;
declare type CbRes<TRes> = (res: AxiosResponse<TRes>) => void;
declare type EvtConf<T> = {
    bind: Record<string, any>;
    msg: T;
};
declare type EvtRes<T> = Signal.WithData<T> & {
    listenOnceAsync: (p?: {
        resolveIf?: (msg: T) => boolean;
        timeout?: Timeout;
    }) => Promise<T>;
};
export {};
//# sourceMappingURL=aqm-reqs.d.ts.map