const registry = {};
/**
 * Cache, using In-Memory Cache (Map)
 * @param name - name of the cache (used as an identifier)
 * @returns Object with set, get and delete methods
 */
export const inMemoryCache = async (name) => {
    if (registry[name] === undefined) {
        registry[name] = new Map();
    }
    return {
        async set(request, response) {
            registry[name].set(request.url, await response.text());
        },
        async get(request) {
            return registry[name].get(request.url);
        },
        async delete(request) {
            registry[name].delete(request.url);
        },
    };
};
/**
 * Cache, using Web API Cache
 * @param name - name of the cache (used as an identifier)
 * @returns Object with set, get and delete methods
 */
export const webAPIIconsCache = async (name) => {
    const cache = await caches.open(name);
    return {
        set: async (request, response) => {
            await cache.put(request, response);
        },
        get: async (request) => {
            const response = await cache.match(request);
            return response === null || response === void 0 ? void 0 : response.text();
        },
        delete: async (request) => {
            await cache.delete(request);
        },
    };
};
/**
 * Function to return the cache based on the cache strategy
 * @param cacheName - name of the cache to be used
 * @param cacheStrategy - strategy to be used for caching
 * @returns the cache based on the strategy
 */
export const iconsCache = async (cacheName, cacheStrategy) => {
    if (cacheStrategy === 'in-memory-cache') {
        return inMemoryCache(cacheName);
    }
    return webAPIIconsCache(cacheName);
};
