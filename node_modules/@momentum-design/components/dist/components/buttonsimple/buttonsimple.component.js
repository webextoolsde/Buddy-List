var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { html } from 'lit';
import { property } from 'lit/decorators.js';
import { Component } from '../../models';
import { DisabledMixin } from '../../utils/mixins/DisabledMixin';
import { TabIndexMixin } from '../../utils/mixins/TabIndexMixin';
import { BUTTON_TYPE, DEFAULTS } from './buttonsimple.constants';
import styles from './buttonsimple.styles';
/**
 * `mdc-buttonsimple` is a component that can be configured in various ways to suit different use cases.
 * It is used as an internal component and is not intended to be used directly by consumers.
 * Consumers should use the `mdc-button` component instead.
 *
 * @tagname mdc-buttonsimple
 */
class Buttonsimple extends TabIndexMixin(DisabledMixin(Component)) {
    /** @internal */
    get form() {
        return this.internals.form;
    }
    constructor() {
        super();
        /**
         * The button's active state indicates whether it is currently toggled on (active) or off (inactive).
         * When the active state is true, the button is considered to be in an active state, meaning it is toggled on.
         * Conversely, when the active state is false, the button is in an inactive state, indicating it is toggled off.
         * @default false
         */
        this.active = false;
        /**
         * Indicates whether the button is soft disabled.
         * When set to `true`, the button appears visually disabled but still allows
         * focus, click, and keyboard actions to be passed through.
         *
         * **Important:** When using soft disabled, consumers must ensure that
         * the button behaves like a disabled button, allowing only focus and
         * preventing any interactions (clicks or keyboard actions) from triggering unintended actions.
         * @default false
         */
        this.softDisabled = false;
        /**
         * Simplebutton size is a super set of all the sizes supported by children components.
         * @default 32
         */
        this.size = DEFAULTS.SIZE;
        /**
         * This property defines the ARIA role for the element. By default, it is set to 'button'.
         * Consumers should override this role when:
         * - The element is being used in a context where a different role is more appropriate.
         * - Custom behaviors are implemented that require a specific ARIA role for accessibility purposes.
         * @default button
         */
        this.role = DEFAULTS.ROLE;
        /**
         * This property defines the type attribute for the button element.
         * The type attribute specifies the behavior of the button when it is clicked.
         * - **submit**: The button submits the form data to the server.
         * - **reset**: The button resets the form data to its initial state.
         * - **button**: The button does nothing when clicked.
         * @default button
         */
        this.type = DEFAULTS.TYPE;
        /**
         * @internal
         */
        this.prevTabindex = 0;
        this.addEventListener('click', this.executeAction.bind(this));
        this.addEventListener('keydown', this.handleKeyDown.bind(this));
        this.addEventListener('keyup', this.handleKeyUp.bind(this));
        /** @internal */
        this.internals = this.attachInternals();
    }
    update(changedProperties) {
        super.update(changedProperties);
        if (changedProperties.has('disabled')) {
            this.setDisabled(this, this.disabled);
        }
        if (changedProperties.has('softDisabled')) {
            this.setSoftDisabled(this, this.softDisabled);
        }
        if (changedProperties.has('active')) {
            this.setActive(this, this.active);
        }
    }
    executeAction() {
        if (this.type === BUTTON_TYPE.SUBMIT && this.internals.form) {
            this.internals.form.requestSubmit();
        }
        if (this.type === BUTTON_TYPE.RESET && this.internals.form) {
            this.internals.form.reset();
        }
    }
    /**
     * Sets the aria-pressed attribute based on the active state of the button.
     * @param element - The button element
     * @param active - The active state of the element
     */
    setActive(element, active) {
        if (active) {
            element.setAttribute('aria-pressed', 'true');
        }
        else {
            element.removeAttribute('aria-pressed');
        }
    }
    /**
     * Sets the soft-disabled attribute for the button.
     * When soft-disabled, the button looks to be disabled but remains focusable and clickable.
     * Also sets/removes aria-disabled attribute.
     *
     * @param element - The button element.
     * @param softDisabled - The soft-disabled state.
     */
    setSoftDisabled(element, softDisabled) {
        if (softDisabled) {
            element.setAttribute('aria-disabled', 'true');
        }
        else {
            element.removeAttribute('aria-disabled');
        }
    }
    /**
     * Sets the disabled attribute for the button.
     * When disabled, the button is not focusable or clickable, and tabindex is set to -1.
     * The previous tabindex is stored and restored when enabled.
     * Also sets/removes aria-disabled attribute.
     *
     * @param element - The button element.
     * @param disabled - The disabled state.
     */
    setDisabled(element, disabled) {
        if (disabled) {
            element.setAttribute('aria-disabled', 'true');
            this.prevTabindex = this.tabIndex;
            this.tabIndex = -1;
        }
        else {
            if (this.tabIndex === -1) {
                this.tabIndex = this.prevTabindex;
            }
            element.removeAttribute('aria-disabled');
        }
    }
    triggerClickEvent() {
        const clickEvent = new MouseEvent('click', {
            bubbles: true,
            cancelable: true,
            view: window,
        });
        this.dispatchEvent(clickEvent);
    }
    /**
     * Handles the keydown event on the button.
     * If the key is 'Enter' or 'Space', the button is pressed.
     * If the key is 'Enter', the button is pressed. The native HTML button works in the same way.
     *
     * @param event - The keyboard event.
     */
    handleKeyDown(event) {
        if (['Enter', ' '].includes(event.key)) {
            this.classList.add('pressed');
            if (event.key === 'Enter') {
                this.triggerClickEvent();
            }
        }
    }
    /**
     * Handles the keyup event on the button.
     * If the key is 'Enter' or 'Space', the button is clicked.
     * If the key is 'Space', the button is pressed. The native HTML button works in the same way.
     *
     * @param event - The keyboard event.
     */
    handleKeyUp(event) {
        if (['Enter', ' '].includes(event.key)) {
            this.classList.remove('pressed');
            if (event.key === ' ') {
                this.triggerClickEvent();
            }
        }
    }
    render() {
        return html `
      <slot></slot>
    `;
    }
}
/** @internal */
Buttonsimple.formAssociated = true;
Buttonsimple.styles = [...Component.styles, ...styles];
__decorate([
    property({ type: Boolean, reflect: true }),
    __metadata("design:type", Object)
], Buttonsimple.prototype, "active", void 0);
__decorate([
    property({ type: Boolean, attribute: 'soft-disabled' }),
    __metadata("design:type", Object)
], Buttonsimple.prototype, "softDisabled", void 0);
__decorate([
    property({ type: Number, reflect: true }),
    __metadata("design:type", Number)
], Buttonsimple.prototype, "size", void 0);
__decorate([
    property({ type: String, reflect: true }),
    __metadata("design:type", Object)
], Buttonsimple.prototype, "role", void 0);
__decorate([
    property({ reflect: true }),
    __metadata("design:type", String)
], Buttonsimple.prototype, "type", void 0);
export default Buttonsimple;
