var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { html } from 'lit';
import { property, state } from 'lit/decorators.js';
import styles from './icon.styles';
import { Component } from '../../models';
import providerUtils from '../../utils/provider';
import IconProvider from '../iconprovider/iconprovider.component';
import { dynamicSVGImport } from './icon.utils';
import { DEFAULTS } from './icon.constants';
/**
 * Icon component that dynamically displays SVG icons based on a valid name.
 *
 * This component must be mounted within an `IconProvider` component.
 *
 * The `IconProvider` defines the source URL from which icons are consumed.
 * The `Icon` component accepts a `name` attribute, which corresponds to
 * the file name of the icon to be loaded from the specified URL.
 *
 * Once fetched, the icon will be rendered. If the fetching process is unsuccessful,
 * no icon will be displayed.
 *
 * The `size` attribute allows for dynamic sizing of the icon based on the provided
 * `length-unit` attribute. This unit can either come from the `IconProvider`
 * or can be overridden for each individual icon. For example:
 * if `size = 1` and `length-unit = 'em'`, the dimensions of the icon will be
 * `width: 1em; height: 1em`.
 *
 * Regarding accessibility, there are three types of icons: decorative, informative and informative standalone.
 *
 * ### Decorative Icons
 * - Decorative icons do not convey any essential information to the content of a page.
 * - They should be hidden from screen readers (SR) to prevent confusion for users.
 * - For decorative icons, an `aria-label` is not required, and the `role` will be set to null.
 *
 * ### Informative Icons
 * - Informative icons convey important information that is not adequately represented
 *   by surrounding text or components.
 * - They provide valuable context and must be announced by assistive technologies.
 * - For informative icons, an `aria-label` is required, and the `role` will be set to "img" automatically.
 * - If an `aria-label` is provided, the role will be set to 'img'; if it is absent,
 *   the role will be unset.
 *
 * ### Informative Standalone Icons
 * - If an icon is informative (as mentioned above) and does not belong to a button (=standalone), it must
 * have a Tooltip that describes what it means.
 * - For informative standalone icons, an `aria-label` & `tabindex="0"` is required,
 * and the `role` will be set to "img" automatically.
 * - **Only use this when a Icon is standalone and is not part of a button or other interactive elements.**
 *
 * @tagname mdc-icon
 *
 * @cssproperty --mdc-icon-fill-color - Allows customization of the default fill color.
 * @cssproperty --mdc-icon-size - Allows customization of the icon size.
 * @cssproperty --mdc-icon-border-radius - Allows customization of the icon border radius.
 */
class Icon extends Component {
    constructor() {
        super();
        /**
         * Name of the icon (= filename)
         */
        this.name = DEFAULTS.NAME;
        /**
         * Aria-label attribute to be set for accessibility
         */
        this.ariaLabel = null;
        this.iconProviderContext = providerUtils.consume({ host: this, context: IconProvider.Context });
        this.abortController = new AbortController(); // Initialize AbortController
    }
    /**
     * Parse the icon string to an html element, set the attributes and
     * return the icon element
     *
     * @param iconData - The icon string to be parsed
     * @returns iconElement
     */
    prepareIconElement(iconData) {
        const iconElement = new DOMParser().parseFromString(iconData, 'text/html').body.children[0];
        if (this.name) {
            iconElement.setAttribute('data-name', this.name);
        }
        iconElement.setAttribute('part', 'icon');
        // set aria-hidden=true for SVG to avoid screen readers
        iconElement.setAttribute('aria-hidden', 'true');
        return iconElement;
    }
    /**
     * Fetches the icon (currently only svg) and sets state and attributes once fetched successfully
     *
     * This method uses abortController.signal to cancel the fetch request when the component is disconnected or updated.
     * If the request is aborted after the fetch() call has been fulfilled but before the response body has been read,
     * then attempting to read the response body will reject with an AbortError exception.
     */
    async getIconData() {
        if (this.iconProviderContext.value) {
            const { fileExtension, url, cacheName, cacheStrategy } = this.iconProviderContext.value;
            if (url && fileExtension && this.name) {
                // function to abort the fetch request and create a new signal
                // (directly passing the abortcontroller to the fetch request per reference
                // will not work due to JS call-by-sharing behavior)
                const renewSignal = () => {
                    this.abortController.abort();
                    this.abortController = new AbortController();
                    return this.abortController.signal;
                };
                try {
                    // fetch icon data (including caching logic)
                    const iconData = await dynamicSVGImport({
                        url,
                        name: this.name,
                        fileExtension,
                        cacheName,
                        cacheStrategy,
                        renewSignal,
                    });
                    // parse the fetched icon string to an html element and set the attributes
                    const iconElement = this.prepareIconElement(iconData);
                    this.handleIconLoadedSuccess(iconElement);
                }
                catch (error) {
                    this.handleIconLoadedFailure(error);
                }
            }
        }
    }
    /**
     * Sets the iconData state to the fetched icon.
     * Dispatches a 'load' event on the component once the icon has been successfully loaded.
     * @param iconHtml - The icon html element which has been fetched from the icon provider.
     */
    handleIconLoadedSuccess(iconHtml) {
        // update iconData state once fetched:
        this.iconData = iconHtml;
        // when icon is fetched successfully, trigger icon load event.
        const loadEvent = new Event('load', {
            bubbles: true,
            cancelable: true,
        });
        this.dispatchEvent(loadEvent);
    }
    /**
     * Dispatches an 'error' event on the component when the icon fetching has failed.
     * This event bubbles and is cancelable.
     * The error detail is set to the error object.
     */
    handleIconLoadedFailure(error) {
        const errorEvent = new CustomEvent('error', {
            bubbles: true,
            cancelable: true,
            detail: { error },
        });
        this.dispatchEvent(errorEvent);
    }
    /**
     * Updates the size by setting the width and height
     */
    updateSize() {
        var _a;
        if (this.computedIconSize && (this.lengthUnit || this.lengthUnitFromContext)) {
            const value = `${this.computedIconSize}${(_a = this.lengthUnit) !== null && _a !== void 0 ? _a : this.lengthUnitFromContext}`;
            // set the computed icon size as a css variable to be used in the icon styles
            this.style.setProperty('--computed-icon-size', value);
        }
    }
    get computedIconSize() {
        var _a, _b;
        return (_b = (_a = this.size) !== null && _a !== void 0 ? _a : this.sizeFromContext) !== null && _b !== void 0 ? _b : DEFAULTS.SIZE;
    }
    updated(changedProperties) {
        var _a, _b, _c, _d;
        super.updated(changedProperties);
        if (changedProperties.has('name')) {
            // fetch icon data if name changes:
            this.getIconData().catch((err) => {
                if (err.name !== 'AbortError' && this.onerror) {
                    this.onerror(err);
                }
            });
        }
        if (changedProperties.has('ariaLabel')) {
            this.role = this.ariaLabel ? 'img' : null;
        }
        if (changedProperties.has('size') || changedProperties.has('lengthUnit')) {
            this.updateSize();
        }
        if (this.lengthUnitFromContext !== ((_a = this.iconProviderContext.value) === null || _a === void 0 ? void 0 : _a.lengthUnit)) {
            this.lengthUnitFromContext = (_b = this.iconProviderContext.value) === null || _b === void 0 ? void 0 : _b.lengthUnit;
            this.updateSize();
        }
        if (this.sizeFromContext !== ((_c = this.iconProviderContext.value) === null || _c === void 0 ? void 0 : _c.size)) {
            this.sizeFromContext = (_d = this.iconProviderContext.value) === null || _d === void 0 ? void 0 : _d.size;
            this.updateSize();
        }
    }
    render() {
        return html ` ${this.iconData} `;
    }
}
Icon.styles = [...Component.styles, ...styles];
__decorate([
    state(),
    __metadata("design:type", HTMLElement)
], Icon.prototype, "iconData", void 0);
__decorate([
    state(),
    __metadata("design:type", String)
], Icon.prototype, "lengthUnitFromContext", void 0);
__decorate([
    state(),
    __metadata("design:type", Number)
], Icon.prototype, "sizeFromContext", void 0);
__decorate([
    property({ type: String, reflect: true }),
    __metadata("design:type", String)
], Icon.prototype, "name", void 0);
__decorate([
    property({ type: Number }),
    __metadata("design:type", Number)
], Icon.prototype, "size", void 0);
__decorate([
    property({ type: String, attribute: 'length-unit' }),
    __metadata("design:type", String)
], Icon.prototype, "lengthUnit", void 0);
__decorate([
    property({ type: String, attribute: 'aria-label' }),
    __metadata("design:type", Object)
], Icon.prototype, "ariaLabel", void 0);
__decorate([
    state(),
    __metadata("design:type", AbortController)
], Icon.prototype, "abortController", void 0);
export default Icon;
