var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { html, nothing } from 'lit';
import { property, query } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import styles from './input.styles';
import FormfieldWrapper from '../formfieldwrapper';
import { NameMixin } from '../../utils/mixins/NameMixin';
import { AUTO_CAPITALIZE, DEFAULTS, PREFIX_TEXT_OPTIONS } from './input.constants';
import { DEFAULTS as FORMFIELD_DEFAULTS } from '../formfieldwrapper/formfieldwrapper.constants';
import { ValueMixin } from '../../utils/mixins/ValueMixin';
import { DataAriaLabelMixin } from '../../utils/mixins/DataAriaLabelMixin';
/**
 * mdc-input is a component that allows users to input text.
 *  It contains:
 * - label field - describe the input field.
 * - input field - contains the value
 * - help text or validation message - displayed below the input field.
 * - trailing button - it displays a clear the input field.
 * - prefix text - displayed before the input field.
 * - leading icon - displayed before the input field.
 * - clear-aria-label - aria label for the trailing button.
 * - all the attributes of the input field.
 *
 * @tagname mdc-input
 *
 * @dependency mdc-icon
 * @dependency mdc-text
 * @dependency mdc-button
 *
 * @cssproperty --mdc-input-disabled-border-color - Border color for the input container when disabled
 * @cssproperty --mdc-input-disabled-text-color - Text color for the input field when disabled
 * @cssproperty --mdc-input-disabled-background-color - Background color for the input field when disabled
 * @cssproperty --mdc-input-border-color - Border color for the input container
 * @cssproperty --mdc-input-text-color - Text color for the input field
 * @cssproperty --mdc-input-background-color - Background color for the input field
 * @cssproperty --mdc-input-selection-background-color - Background color for the selected text
 * @cssproperty --mdc-input-selection-text-color - Text color for the selected text
 * @cssproperty --mdc-input-support-text-color - Text color for the help text
 * @cssproperty --mdc-input-hover-background-color - Background color for the input field when hovered
 * @cssproperty --mdc-input-focused-background-color - Background color for the input field when focused
 * @cssproperty --mdc-input-focused-border-color - Border color for the input container when focused
 * @cssproperty --mdc-input-error-border-color - Border color for the input container when error
 * @cssproperty --mdc-input-warning-border-color - Border color for the input container when warning
 * @cssproperty --mdc-input-success-border-color - Border color for the input container when success
 * @cssproperty --mdc-input-primary-border-color - Border color for the input container when primary
 *
 */
class Input extends DataAriaLabelMixin(ValueMixin(NameMixin(FormfieldWrapper))) {
    checkValidity() {
        this.setValidityFromInput();
        return this.internals.checkValidity();
    }
    reportValidity() {
        this.setValidityFromInput();
        return this.internals.reportValidity();
    }
    /** @internal */
    get form() {
        return this.internals.form;
    }
    constructor() {
        super();
        /**
         * The placeholder text that is displayed when the input field is empty.
         */
        this.placeholder = '';
        /**
         * readonly attribute of the input field. If true, the input field is read-only.
         */
        this.readonly = false;
        /**
         * The trailing button when set to true, shows a clear button that clears the input field.
         * @default false
         */
        this.trailingButton = false;
        /**
         * The autocapitalize attribute of the input field.
         * @default 'off'
         */
        this.autocapitalize = AUTO_CAPITALIZE.OFF;
        /**
         * The autocomplete attribute of the input field.
         * @default 'off'
         */
        this.autocomplete = 'off';
        /**
         * If true, the input field is focused when the component is rendered.
         * @default false
         */
        this.autofocus = false;
        /**
         * Aria label for the trailing button. If trailing button is set to true, this label is used for the clear button.
         * @default ''
         */
        this.clearAriaLabel = '';
        /** @internal */
        this.internals = this.attachInternals();
    }
    connectedCallback() {
        super.connectedCallback();
        this.updateComplete.then(() => {
            if (this.inputElement) {
                this.inputElement.checkValidity();
                this.setValidityFromInput();
                this.internals.setFormValue(this.inputElement.value);
            }
        }).catch((error) => {
            if (this.onerror) {
                this.onerror(error);
            }
        });
    }
    updated(changedProperties) {
        super.updated(changedProperties);
        if (changedProperties.has('value')) {
            this.handleValueChange();
        }
    }
    /**
   * Handles the value change of the input field.
   * Sets the form value and updates the validity of the input field.
   * @returns void
   */
    handleValueChange() {
        this.internals.setFormValue(this.value);
        this.updateComplete.then(() => {
            this.setValidityFromInput();
        }).catch((error) => {
            if (this.onerror) {
                this.onerror(error);
            }
        });
    }
    /**
   * This function is called when the attribute changes.
   * It updates the validity of the input field based on the input field's validity.
   *
   * @param name - attribute name
   * @param old - old value
   * @param value - new value
   */
    attributeChangedCallback(name, old, value) {
        super.attributeChangedCallback(name, old, value);
        const validationRelatedAttributes = [
            'maxlength',
            'minlength',
            'pattern',
            'required',
        ];
        if (validationRelatedAttributes.includes(name)) {
            this.updateComplete.then(() => {
                this.setValidityFromInput();
            }).catch((error) => {
                if (this.onerror) {
                    this.onerror(error);
                }
            });
        }
    }
    /**
   * Sets the validity of the input field based on the input field's validity.
   * @returns void
   */
    setValidityFromInput() {
        if (this.inputElement) {
            this.internals.setValidity(this.inputElement.validity, this.inputElement.validationMessage, this.inputElement);
        }
    }
    /**
   * Updates the value of the input field.
   * Sets the form value.
   * @returns void
   */
    updateValue() {
        this.value = this.inputElement.value;
        this.internals.setFormValue(this.inputElement.value);
    }
    /**
   * Handles the input event of the input field.
   * Updates the value and sets the validity of the input field.
   *
   */
    onInput() {
        this.updateValue();
        this.setValidityFromInput();
    }
    /**
   * Handles the change event of the input field.
   * Updates the value and sets the validity of the input field.
   *
   * The 'change' event does not bubble up through the shadow DOM as it was not composed.
   * Therefore, we need to re-dispatch the same event to ensure it is propagated correctly.
   * Read more: https://developer.mozilla.org/en-US/docs/Web/API/Event/composed
   *
   * @param event - Event which contains information about the value change.
   */
    onChange(event) {
        this.updateValue();
        this.setValidityFromInput();
        const EventConstructor = event.constructor;
        this.dispatchEvent(new EventConstructor(event.type, event));
    }
    /**
     * Handles the keydown event of the input field.
     * If the key pressed is 'Enter', it submits the form.
     * @param event - Keyboard event
     */
    handleKeyDown(event) {
        var _a;
        if (event.key === 'Enter') {
            (_a = this.internals.form) === null || _a === void 0 ? void 0 : _a.requestSubmit();
        }
    }
    /**
   * Renders the leading icon before the input field.
   * If the leading icon is not set, it will not be displayed.
   *
   * @returns void
   */
    renderLeadingIcon() {
        if (!this.leadingIcon) {
            return nothing;
        }
        return html `
      <mdc-icon 
        class="leading-icon" 
        part="leading-icon"
        name=${this.leadingIcon} 
        size="${DEFAULTS.ICON_SIZE_VALUE}" 
        length-unit="${DEFAULTS.ICON_SIZE_UNIT}">
      </mdc-icon>
    `;
    }
    /**
   * Renders the prefix text before the input field.
   * If the prefix text is more than 10 characters,
   * - it will not be displayed.
   * - the validation messsage will be displayed.
   *
   *  Note: We are setting aria-hidden so that the screen reader does not read the prefix text.
   *  The consumers should set the appropriate aria-label for the input field using 'data-aria-label' attribute.
   * @returns void
   */
    renderPrefixText() {
        if (!this.prefixText) {
            return nothing;
        }
        return html `
      <mdc-text 
        class="prefix-text" 
        tagname="${DEFAULTS.PREFIX_TEXT_TAG}" 
        type="${DEFAULTS.PREFIX_TEXT_TYPE}"
        aria-hidden="true"
      >
        ${this.prefixText.slice(0, PREFIX_TEXT_OPTIONS.MAX_LENGTH)}
      </mdc-text>
    `;
    }
    /**
   * Clears the input field.
   */
    clearInputText() {
        var _a;
        this.value = '';
        // focus the input field after clearing the text
        (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.focus();
    }
    /**
   * Renders the trailing button to clear the input field if the trailingButton is set to true.
   * @returns void
   */
    renderTrailingButton() {
        if (!this.trailingButton) {
            return nothing;
        }
        return html `
      <mdc-button 
        part='trailing-button'
        class='${!this.value ? 'hidden' : ''}'
        prefix-icon='${DEFAULTS.CLEAR_BUTTON_ICON}'
        variant='${DEFAULTS.CLEAR_BUTTON_VARIANT}'
        size="${DEFAULTS.CLEAR_BUTTON_SIZE}"
        aria-label="${this.clearAriaLabel}"
        @click=${this.clearInputText}
        ?disabled=${this.disabled || this.readonly || !this.value}
      ></mdc-button>
    `;
    }
    render() {
        var _a;
        return html `
      ${this.renderLabel()}
      <div class="input-container mdc-focus-ring" part="input-container">
        <slot name="input-leading-icon">${this.renderLeadingIcon()}</slot>
       <div class="input-section" part="input-section">
       <slot name="input-prefix-text">${this.renderPrefixText()}</slot>
        <slot name="input">
          <input 
            aria-label="${(_a = this.dataAriaLabel) !== null && _a !== void 0 ? _a : ''}"
            class='input'
            part='input'
            id="${this.id}"
            name="${this.name}"
            .value="${this.value}"
            ?disabled="${this.disabled}"
            ?readonly="${this.readonly}"
            ?required="${!!this.requiredLabel}"
            type="text"
            aria-describedby="${FORMFIELD_DEFAULTS.HELPER_TEXT_ID}"
            placeholder=${ifDefined(this.placeholder)}
            minlength=${ifDefined(this.minlength)}
            maxlength=${ifDefined(this.maxlength)}
            autocapitalize=${this.autocapitalize}
            autocomplete=${this.autocomplete}
            ?autofocus="${this.autofocus}"
            dirname=${ifDefined(this.dirname)}
            pattern=${ifDefined(this.pattern)}
            list=${ifDefined(this.list)}
            size=${ifDefined(this.size)}
            @input=${this.onInput}
            @change=${this.onChange}
            @keydown=${this.handleKeyDown}
          />
        </slot>
       </div>
        <slot name="trailing-button">${this.renderTrailingButton()}</slot>
      </div>
      ${this.helpText ? this.renderHelperText() : nothing}
    `;
    }
}
/** @internal */
Input.formAssociated = true;
Input.styles = [...FormfieldWrapper.styles, ...styles];
__decorate([
    property({ type: String }),
    __metadata("design:type", Object)
], Input.prototype, "placeholder", void 0);
__decorate([
    property({ type: Boolean }),
    __metadata("design:type", Object)
], Input.prototype, "readonly", void 0);
__decorate([
    property({ type: String, attribute: 'prefix-text' }),
    __metadata("design:type", String)
], Input.prototype, "prefixText", void 0);
__decorate([
    property({ type: String, attribute: 'leading-icon' }),
    __metadata("design:type", String)
], Input.prototype, "leadingIcon", void 0);
__decorate([
    property({ type: Boolean, attribute: 'trailing-button' }),
    __metadata("design:type", Object)
], Input.prototype, "trailingButton", void 0);
__decorate([
    property({ type: Number }),
    __metadata("design:type", Number)
], Input.prototype, "maxlength", void 0);
__decorate([
    property({ type: Number }),
    __metadata("design:type", Number)
], Input.prototype, "minlength", void 0);
__decorate([
    property({ type: String }),
    __metadata("design:type", String)
], Input.prototype, "autocapitalize", void 0);
__decorate([
    property({ type: String }),
    __metadata("design:type", Object)
], Input.prototype, "autocomplete", void 0);
__decorate([
    property({ type: Boolean }),
    __metadata("design:type", Object)
], Input.prototype, "autofocus", void 0);
__decorate([
    property({ type: String }),
    __metadata("design:type", String)
], Input.prototype, "dirname", void 0);
__decorate([
    property({ type: String }),
    __metadata("design:type", String)
], Input.prototype, "pattern", void 0);
__decorate([
    property({ type: String }),
    __metadata("design:type", String)
], Input.prototype, "list", void 0);
__decorate([
    property({ type: Number }),
    __metadata("design:type", Object)
], Input.prototype, "size", void 0);
__decorate([
    property({ type: String, attribute: 'clear-aria-label' }),
    __metadata("design:type", Object)
], Input.prototype, "clearAriaLabel", void 0);
__decorate([
    query('input'),
    __metadata("design:type", HTMLInputElement)
], Input.prototype, "inputElement", void 0);
export default Input;
