var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { html, nothing } from 'lit';
import { property } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { NameMixin } from '../../utils/mixins/NameMixin';
import { ValueMixin } from '../../utils/mixins/ValueMixin';
import styles from './radio.styles';
import FormfieldWrapper from '../formfieldwrapper/formfieldwrapper.component';
import { DataAriaLabelMixin } from '../../utils/mixins/DataAriaLabelMixin';
import { DEFAULTS as FORMFIELD_DEFAULTS } from '../formfieldwrapper/formfieldwrapper.constants';
/**
 * Radio allow users to select single options from a list or turn an item/feature on or off.
 * These are often used in forms, settings, and selection in lists.
 *
 * A radio component contains an optional label, optional info icon and an optional helper text.
 * @dependency mdc-formfieldwrapper
 *
 * @tagname mdc-radio
 *
 * @cssproperty --mdc-radio-inner-circle-size - size of the inner circle
 * @cssproperty --mdc-radio-text-disabled-color - color of the label when disabled
 * @cssproperty --mdc-radio-disabled-border-color - color of the radio button border when disabled
 * @cssproperty --mdc-radio-normal-border-color - color of the radio button border when normal
 * @cssproperty --mdc-radio-inner-circle-normal-background - background color of the inner circle when normal
 * @cssproperty --mdc-radio-inner-circle-disabled-background - background color of the inner circle when disabled
 * @cssproperty --mdc-radio-control-inactive-color - color of the radio button when inactive
 * @cssproperty --mdc-radio-control-inactive-hover - color of the radio button when inactive and hovered
 * @cssproperty --mdc-radio-control-inactive-pressed-color - color of the radio button when inactive and pressed
 * @cssproperty --mdc-radio-control-inactive-disabled-background - background color of the radio button when
 *  inactive and disabled
 * @cssproperty --mdc-radio-control-active-color - color of the radio button when active
 * @cssproperty --mdc-radio-control-active-hover-color - color of the radio button when active and hovered
 * @cssproperty --mdc-radio-control-active-pressed-color - color of the radio button when active and pressed
 * @cssproperty --mdc-radio-control-active-disabled-background - background color of the radio button
 *  when active and disabled
 *
 */
class Radio extends NameMixin(ValueMixin(DataAriaLabelMixin(FormfieldWrapper))) {
    /** @internal */
    get form() {
        return this.internals.form;
    }
    constructor() {
        super();
        /**
        * Determines whether the radio is selected or unselected.
        *
        * @default false
        */
        this.checked = false;
        /**
        * Determines whether the radio is read-only.
        *
        * @default false
        */
        this.readonly = false;
        /** @internal */
        this.internals = this.attachInternals();
    }
    /**
     * Updates the form value to reflect the current state of the radio.
     * If checked, the value is set to the user-provided value.
     * If unchecked, the value is set to null.
     */
    setFormValue() {
        if (this.checked) {
            this.internals.setFormValue(this.value);
        }
    }
    firstUpdated() {
        this.updateTabIndex();
    }
    /**
     * Returns all radios within the same group (name).
     */
    getAllRadiosWithinSameGroup() {
        return Array.from(document.querySelectorAll(`mdc-radio[name="${this.name}"]`));
    }
    /**
     * The 'change' event does not bubble up through the shadow DOM as it was not composed.
     * Therefore, we need to re-dispatch the same event to ensure it is propagated correctly.
     * Read more: https://developer.mozilla.org/en-US/docs/Web/API/Event/composed
     */
    dispatchChangeEvent(event) {
        const EventConstructor = event.constructor;
        this.dispatchEvent(new EventConstructor(event.type, event));
    }
    /**
     * Handles the change event on the radio element.
     * This will toggle the state of the radio element.
     * Dispatches the change event.
     */
    handleChange(event) {
        var _a;
        if (this.disabled || this.readonly)
            return;
        const radios = this.getAllRadiosWithinSameGroup();
        radios.forEach((radio) => {
            var _a;
            /**
              *  Uncheck all radios in the same group (name)
            */
            const radioElement = (_a = radio.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('input');
            if (radioElement) {
                // eslint-disable-next-line no-param-reassign
                radio.checked = false;
                radioElement.checked = false;
            }
        });
        this.checked = true;
        const inputElement = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('input');
        if (inputElement) {
            inputElement.checked = true;
        }
        this.dispatchChangeEvent(event);
    }
    /**
     * Updates the state of the radio button at the specified index within the enabled radios.
     * Focuses the radio button and triggers the change event if the radio button is not read-only.
     *
     * @param enabledRadios - An array of enabled radio buttons within the same group.
     * @param index - The index of the radio button to be updated within the enabled radios array.
     * @param event - The event that triggered the update.
     */
    updateRadio(enabledRadios, index, event) {
        var _a, _b;
        (_b = (_a = enabledRadios[index].shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('input')) === null || _b === void 0 ? void 0 : _b.focus();
        enabledRadios[index].handleChange(event);
    }
    /**
     * Handles the keydown event (Arrow Up/Down/Left/Right) on the radio element.
     */
    handleKeyDown(event) {
        if (this.disabled)
            return;
        const radios = this.getAllRadiosWithinSameGroup();
        const enabledRadios = radios.filter((radio) => !radio.disabled);
        const currentIndex = enabledRadios.indexOf(this);
        if (['ArrowDown', 'ArrowRight'].includes(event.key)) {
            // Move focus to the next radio
            const nextIndex = (currentIndex + 1) % enabledRadios.length;
            this.updateRadio(enabledRadios, nextIndex, event);
        }
        else if (['ArrowUp', 'ArrowLeft'].includes(event.key)) {
            // Move focus to the previous radio
            const prevIndex = (currentIndex - 1 + enabledRadios.length) % enabledRadios.length;
            this.updateRadio(enabledRadios, prevIndex, event);
        }
        this.updateTabIndex();
    }
    /**
     * Update tab index for all radios in the same group (name)
     * If any radio group is checked, it will have a tab index of 0
     * If no radio group is checked, the first enabled radio will have a tab index of 0
     */
    updateTabIndex() {
        const radios = this.getAllRadiosWithinSameGroup();
        const checked = radios.find((radio) => radio.checked);
        const firstEnabledRadio = radios.find((radio) => !radio.disabled);
        radios.forEach((radio) => {
            var _a;
            const inputElement = (_a = radio.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('input');
            if (inputElement) {
                inputElement.tabIndex = -1;
                if (radio === checked) {
                    inputElement.tabIndex = 0;
                }
                else if (!checked && radio === firstEnabledRadio) {
                    inputElement.tabIndex = 0;
                }
            }
        });
    }
    update(changedProperties) {
        super.update(changedProperties);
        if (changedProperties.has('checked')) {
            this.setFormValue();
        }
    }
    render() {
        var _a;
        const helpTextContent = this.helpText ? this.renderHelperText() : nothing;
        return html `
      <div class="mdc-radio__container">
        <div class="mdc-radio__icon-container mdc-focus-ring">
          <input
            id="${this.id}"
            type="radio"
            role="radio"
            name="${ifDefined(this.name)}"
            value="${ifDefined(this.value)}"
            @change=${this.handleChange}
            @keydown=${this.handleKeyDown}
            ?checked=${this.checked}
            ?readonly=${this.readonly}
            ?disabled=${this.disabled}
            class="mdc-radio__input"
            aria-checked="${this.checked}"
            aria-describedby="${FORMFIELD_DEFAULTS.HELPER_TEXT_ID}"
            aria-label="${(_a = this.dataAriaLabel) !== null && _a !== void 0 ? _a : ''}"
          />
          <span class="mdc-radio__icon"></span>
        </div>
        <div class="mdc-radio__label-container">
          ${this.renderLabel()}
          ${helpTextContent}
        </div>
      </div>
    `;
    }
}
/** @internal */
Radio.formAssociated = true;
Radio.styles = [...FormfieldWrapper.styles, ...styles];
__decorate([
    property({ type: Boolean, reflect: true }),
    __metadata("design:type", Object)
], Radio.prototype, "checked", void 0);
__decorate([
    property({ type: Boolean, reflect: true }),
    __metadata("design:type", Object)
], Radio.prototype, "readonly", void 0);
export default Radio;
