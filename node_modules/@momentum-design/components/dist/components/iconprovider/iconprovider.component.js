var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { property } from 'lit/decorators.js';
import { Provider } from '../../models';
import IconProviderContext from './iconprovider.context';
import { ALLOWED_FILE_EXTENSIONS, DEFAULTS, ALLOWED_LENGTH_UNITS } from './iconprovider.constants';
/**
 * IconProvider component, which allows to be consumed from sub components
 * (see `providerUtils.consume` for how to consume)
 *
 * Bundling icons will be up to the consumer of this component, such
 * that only a url has to be passed in from which the icons will be
 * fetched.
 *
 * If `cacheStrategy` is provided, the IconProvider will cache the icons
 * in the selected cache (either web-api-cache or in-memory-cache),
 * to avoid fetching the same icon multiple times over the network.
 * This is useful when the same icon is used multiple times in the application.
 * To consider:
 * - The `in-memory-cache` is not persisted and will be lost when the
 * IconProvider is removed from the DOM.
 * - The `web-api-cache` is persisted, but only works in https environments
 * (https://developer.mozilla.org/en-US/docs/Web/API/Cache).
 *
 * @tagname mdc-iconprovider
 *
 * @slot - children
 */
class IconProvider extends Provider {
    constructor() {
        // initialise the context by running the Provider constructor:
        super({
            context: IconProviderContext.context,
            initialValue: new IconProviderContext(),
        });
        /**
         * File extension of icons
         * @default svg
         */
        this.fileExtension = DEFAULTS.FILE_EXTENSION;
        /**
         * Length unit used for sizing of icons
         * @default em
         */
        this.lengthUnit = DEFAULTS.LENGTH_UNIT;
        /**
         * The default size of the icon.
         * If not set, it falls back to the size defined by the length unit.
         * @default 1
         */
        this.size = DEFAULTS.SIZE;
    }
    /**
     * Context object of the IconProvider, to be consumed by child components
     */
    static get Context() {
        return IconProviderContext.context;
    }
    updateValuesInContext() {
        // only update fileExtension on context if its an allowed fileExtension
        if (this.fileExtension && ALLOWED_FILE_EXTENSIONS.includes(this.fileExtension)) {
            this.context.value.fileExtension = this.fileExtension;
        }
        else {
            // Ensure both fileExtension and context are updated to the default if its not an allowed fileExtension
            this.fileExtension = DEFAULTS.FILE_EXTENSION;
            this.context.value.fileExtension = DEFAULTS.FILE_EXTENSION;
        }
        this.context.value.url = this.url;
        this.context.value.size = this.size;
        this.context.value.cacheName = this.cacheName;
        this.context.value.cacheStrategy = this.cacheStrategy;
        if (this.lengthUnit && ALLOWED_LENGTH_UNITS.includes(this.lengthUnit)) {
            this.context.value.lengthUnit = this.lengthUnit;
        }
        else {
            // Ensure both lengthUnit and context are updated to the default if its not an allowed lengthUnit
            this.lengthUnit = DEFAULTS.LENGTH_UNIT;
            this.context.value.lengthUnit = DEFAULTS.LENGTH_UNIT;
        }
    }
    updateContext() {
        if (this.context.value.fileExtension !== this.fileExtension
            || this.context.value.url !== this.url
            || this.context.value.lengthUnit !== this.lengthUnit
            || this.context.value.size !== this.size
            || this.context.value.cacheName !== this.cacheName
            || this.context.value.cacheStrategy !== this.cacheStrategy) {
            this.updateValuesInContext();
            this.context.updateObservers();
        }
    }
}
__decorate([
    property({ type: String }),
    __metadata("design:type", String)
], IconProvider.prototype, "url", void 0);
__decorate([
    property({ type: String, attribute: 'file-extension', reflect: true }),
    __metadata("design:type", String)
], IconProvider.prototype, "fileExtension", void 0);
__decorate([
    property({ type: String, attribute: 'length-unit', reflect: true }),
    __metadata("design:type", String)
], IconProvider.prototype, "lengthUnit", void 0);
__decorate([
    property({ type: Number, reflect: true }),
    __metadata("design:type", Number)
], IconProvider.prototype, "size", void 0);
__decorate([
    property({ type: String, attribute: 'cache-strategy' }),
    __metadata("design:type", String)
], IconProvider.prototype, "cacheStrategy", void 0);
__decorate([
    property({ type: String, attribute: 'cache-name' }),
    __metadata("design:type", String)
], IconProvider.prototype, "cacheName", void 0);
export default IconProvider;
